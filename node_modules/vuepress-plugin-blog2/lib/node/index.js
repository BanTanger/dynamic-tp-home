import{createPage as I,preparePageComponent as B,preparePageData as V,preparePagesComponents as A,preparePagesData as G,preparePagesRoutes as K}from"@vuepress/core";import{watch as j}from"chokidar";import{Logger as F,keys as J,checkVersion as z,getPageExcerpt as W}from"vuepress-shared/node";import{isString as C,isFunction as L,removeLeadingSlash as P}from"@vuepress/shared";import{colors as m}from"@vuepress/utils";const U="vuepress-plugin-blog2",i=new F(U),N=({options:t,pages:M},d)=>{const k=J(t.locales),u={};return(k.length?k:["/"]).forEach(a=>{u[a]=[]}),M.filter(d).forEach(a=>{a.path!=="/404.html"&&u[a.pathLocale].push(a)}),u},q=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
  if (__VUE_HMR_RUNTIME__.updateBlogCategory)
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);
}

if (import.meta.hot)
  import.meta.hot.accept(({ categoryMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);
  });

`,H=(t,{category:M,slugify:d},k,u=!1)=>Promise.all(M.map(async({key:a,getter:h,sorter:$=()=>-1,path:l="/:key/",layout:_="Layout",frontmatter:E=()=>({}),itemPath:v="/:key/:name/",itemLayout:b="Layout",itemFrontmatter:w=()=>({})},g)=>{if(!C(a)||!a.length)return i.error(`Invalid ${m.magenta("key")} option ${m.cyan(a)} in ${m.cyan(`category[${g}]`)}`),null;if(!L(h))return i.error(`Invalid ${m.magenta("getter")} option in "${m.cyan(`category[${g}]`)}", it should be a function!`),null;t.env.isDebug&&i.info(`Generating ${m.cyan(a)} category.
`);const e={},c=[],o=L(v)?v:C(v)?p=>v.replace(/:key/g,d(a)).replace(/:name/g,d(p)):()=>null;for(const p in k){if(l){const r=`${p}${P(l.replace(/:key/g,d(a)))}`,s=await I(t,{path:r,frontmatter:{...E(p),blog:{type:"category",key:a},layout:_}}),n=t.pages.findIndex(({path:f})=>f===r);n===-1?t.pages.push(s):t.pages[n].key!==s.key&&(t.pages.splice(n,1,s),u&&i.warn(`Overriding existed path ${m.cyan(r)}`)),c.push(s.key),e[p]={path:s.path,map:{}}}else e[p]={path:"",map:{}};const{map:y}=e[p],R={};for(const r of k[p]){const s=h(r);for(const n of s){if(!y[n]){const f=o(n);if(f){const T=`${p}${P(f)}`,x=await I(t,{path:`${p}${P(f)}`,frontmatter:{...w(n,p),blog:{type:"category",name:n,key:a},layout:b}}),D=t.pages.findIndex(({path:S})=>S===T);D===-1?t.pages.push(x):t.pages[D].key!==x.key&&(t.pages.splice(D,1,x),u&&i.warn(`Overriding existed path ${T}`)),c.push(x.key),y[n]={path:x.path,keys:[]}}else y[n]={path:"",keys:[]};R[n]=[]}R[n].push(r)}}for(const r in R)y[r].keys=R[r].sort($).map(({key:s})=>s);if(t.env.isDebug){let r=`Route ${p} in ${a} category:
`;for(const s in y){const{path:n,keys:f}=y[s];r+=`name: ${s}; ${n?`path: ${n}; `:""}items: ${f.length}
`}i.info(r)}}return{key:a,map:e,pageKeys:c}})).then(async a=>{const h={},$=[];return a.filter(l=>l!==null).forEach(({key:l,map:_,pageKeys:E})=>{h[l]=_,$.push(...E)}),await t.writeTemp("blog/category.js",`export const categoryMap = ${JSON.stringify(h)};
${t.env.isDev?q:""}
`),t.env.isDebug&&i.info("All categories generated."),$}),Q=t=>{"customElement"in t&&(i.warn(`${m.magenta("customElement")} is deprecated, please use ${m.magenta("isCustomElement")}.`),t.isCustomElement=t.customElement)},X=`
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept();
  if (__VUE_HMR_RUNTIME__.updateBlogType)
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);
}

if (import.meta.hot)
  import.meta.hot.accept(({ typeMap }) => {
    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);
  });
`,O=(t,{type:M,slugify:d},k,u=!1)=>Promise.all(M.map(async({key:a,sorter:h=()=>-1,filter:$=()=>!0,path:l="/:key/",layout:_="Layout",frontmatter:E=()=>({})},v)=>{if(!C(a)||!a.length)return i.error(`Invalid ${m.magenta("key")} option ${m.cyan(a)} in ${m.cyan(`type[${v}]`)}`),null;const b={},w=[];t.env.isDebug&&i.info(`Generating ${m.cyan(a)} type.
`);for(const g in k){const e=k[g].filter($).sort(h).map(({key:c})=>c);if(l){const c=`${g}${P(d(l.replace(/:key/g,a)))}`,o=await I(t,{path:c,frontmatter:{...E(g),blog:{type:"type",key:a},layout:_}}),p=t.pages.findIndex(({path:y})=>y===c);p===-1?t.pages.push(o):t.pages[p].key!==o.key&&(t.pages.splice(p,1,o),u&&i.warn(`Overriding existed path ${m.cyan(c)}`)),w.push(o.key),b[g]={path:o.path,keys:e},t.env.isDebug&&i.info(`Route ${g} in ${a} type: path: ${o.path}; items: ${e.length}
`)}else b[g]={path:"",keys:e},t.env.isDebug&&i.info(`Route ${g} in ${a} type: items: ${e.length}
`)}return{key:a,map:b,pageKeys:w}})).then(async a=>{const h={},$=[];return a.filter(l=>l!==null).forEach(({key:l,map:_,pageKeys:E})=>{h[l]=_,$.push(...E)}),await t.writeTemp("blog/type.js",`export const typeMap = ${JSON.stringify(h)};
${t.env.isDev?X:""}
`),t.env.isDebug&&i.info("All types generated."),$}),Y=(t,M=!0)=>d=>{M&&Q(t),z(d,U,"2.0.0-beta.61");const{getInfo:k=()=>({}),filter:u=e=>!!e.filePathRelative&&!e.frontmatter.home,metaScope:a="_blog",excerpt:h=!0,excerptSeparator:$="<!-- more -->",excerptLength:l=300,excerptFilter:_=u,isCustomElement:E=()=>!1,category:v=[],type:b=[],slugify:w=e=>e.replace(/[ _]/g,"-").replace(/[:?*|\\/<>]/g,"").toLowerCase()}=t;let g=[];return d.env.isDebug&&i.info("Options:",t),{name:U,define:()=>({BLOG_META_SCOPE:a}),extendsPage:e=>{h&&_(e)&&(e.data.excerpt=W(d,e,{isCustomElement:E,excerptSeparator:$,excerptLength:l}))},onInitialized:e=>{const c=N(e,u);return e.pages.filter(u).forEach(o=>{o.routeMeta={...a===""?k(o):{[a]:k(o)},...o.routeMeta}}),Promise.all([H(e,{category:v,slugify:w},c,!0).then(o=>{g.push(...o)}),O(e,{type:b,slugify:w},c,!0).then(o=>{g.push(...o)})]).then(()=>{e.env.isDebug&&i.info("temp file generated")})},onWatched:(e,c)=>{if("hotReload"in t?t.hotReload:e.env.isDebug){const o=j("pages/**/*.js",{cwd:e.dir.temp(),ignoreInitial:!0}),p=()=>{const y=[],R=N(e,u);return Promise.all([H(e,{category:v,slugify:w},R).then(r=>{y.push(...r)}),O(e,{type:b,slugify:w},R).then(r=>{y.push(...r)})]).then(async()=>{const r=g.filter(n=>!y.includes(n)),s=y.filter(n=>!g.includes(n));s.length&&(e.env.isDebug&&i.info(`New pages detected: ${s.toString()}`),await Promise.all(s.map(async n=>{await B(e,e.pages.find(({key:f})=>f===n)),await V(e,e.pages.find(({key:f})=>f===n))}))),r.length&&(e.env.isDebug&&i.info(`Removing following pages: ${r.toString()}`),r.forEach(n=>{e.pages.splice(e.pages.findIndex(({key:f})=>f===n),1)})),(r.length||s.length)&&(await A(e),await G(e),await K(e)),g=y,e.env.isDebug&&i.info("temp file updated")})};o.on("add",()=>{p()}),o.on("change",()=>{p()}),o.on("unlink",()=>{p()}),c.push(o)}}}};export{Y as blogPlugin};
//# sourceMappingURL=index.js.map
